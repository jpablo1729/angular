This is the repro for my angular course.
This is also the place to write my notes of Angular course

Decorators:

Class decorators, e.g. @Component and @NgModule
Property decorators for properties inside classes, e.g. @Input and @Output
Method decorators for methods inside classes, e.g. @HostListener
Parameter decorators for parameters inside class constructors, e.g. @Inject

# Class Decorators
Angular offers us a few class decorators. These are the top-level decorators 
that we use to express intent for classes. They allow us to tell Angular that 
a particular class is a component, or module, for example. And the decorator 
allows us to define this intent without having to actually put any code inside 
the class.

# Property Decorators
These are probably the second most common decorators that you’ll come across. 
They allow us to decorate specific properties within our classes - an extremely 
powerful mechanism.

Let’s take a look at @Input(). Imagine that we have a property within our class 
that we want to be an input binding.

Without decorators, we’d have to define this property in our class anyway for 
TypeScript to know about it, and then somewhere else tell Angular that we’ve 
got a property that we want to be an input.

With decorators, we can simply put the @Input() decorator above the property 
- which Angular’s compiler will automatically create an input binding from the 
property name and link them.

Example:

import { Component, Input } from '@angular/core';

@Component({
  selector: 'example-component',
  template: '<div>Woo a component!</div>'
})
export class ExampleComponent {
  @Input()
  exampleProperty: string;
}

We’d then pass the input binding via a component property binding:

<example-component
  [exampleProperty]="exampleData">
</example-component>

before:

In AngularJS 1.x (I’m going to use TypeScript here also, just to declare a property 
on a class), we had a different mechanism using scope or bindToController with Directives, 
and bindings within the new component method:

const exampleComponent = {
  bindings: {
    exampleProperty: '<',
  },
  template: `
    <div>Woo a component!</div>
  `,
  controller: class ExampleComponent {
    exampleProperty: string;
    $onInit() {
      // access this.exampleProperty
    }
  },
};

angular.module('app').component('exampleComponent', exampleComponent);

# Method Decorators
Method decorators are very similar to property decorators but are used for methods instead. 
This let’s us decorate specific methods within our class with functionality. A good example 
of this is @HostListener. This allows us to tell Angular that when an event on our host 
happens, we want the decorated method to be called with the event.

Exp:

import { Component, HostListener } from '@angular/core';

@Component({
  selector: 'example-component',
  template: '<div>Woo a component!</div>'
})
export class ExampleComponent {
  @HostListener('click', ['$event'])
  onHostClick(event: Event) {
    // clicked, `event` available
  }
}

# Creating a decorator
It makes things a lot easier if we understand what a decorator is actually 
doing before we look into how Angular uses them under the hood. To do this, 
we can create a quick example decorator.

# Decorator functions
Decorators are actually just functions, it’s as simple as that, and are 
called with whatever they are decorating. A method decorator will be called 
with the value of the method it’s decorating, and a class decorator will be 
called with the class to be decorated.

Let’s quickly make a decorator that we can use on a class to demonstrate 
this a little further. This decorator is just going to simply log the class 
to the console:

function Console(target) {
  console.log('Our decorated class', target);
}

Here, we have created Console (using the uppercase naming convention 
Angular uses) and are specifying a single argument called target. 
The target will in fact be the class that we decorate, which means we 
can now decorate any class with our decorator and see it outputted in the console:

@Console
class ExampleClass {
  constructor() {
    console.log('Yo!');
  }
}

# Passing data to a decorator
When we use the decorators in Angular we pass in some form of configuration, 
specific to the decorator.

For example, when we use @Component we pass through an object, and with 
@HostListener we pass through a string as the first argument (the event name, 
such as 'click') and optionally an array of strings for further variables (such as $event) 
to be passed through to the decorated method.

Let’s change our code above to execute the Console function with a value 
to match how we use the Angular decorators.

@Console('Hey!')
class ExampleClass {
  constructor() {
    console.log('Yo!');
  }
}

If we ran this code now, we’d only get 'Hey!' outputted to the console. 
That’s because our decorator hasn’t returned a function for the class to 
be given to. The output of @Console('Hey!') is void.

We would need to adapt our Console decorator to return a function closure 
for the class to be given to. That way we can both receive a value from 
the decorator (in our case, the string Hey!) and also the class that it’s applied to:

function Console(message) {
  // access the "metadata" message
  console.log(message);
  // return a function closure, which
  // is passed the class as `target`
  return function(target) {
    console.log('Our decorated class', target);
  };
}

@Console('Hey!')
class ExampleClass {
  constructor() {
    console.log('Yo!');
  }
}

// console output: 'Hey!'
// console output: 'Our decorated class', class ExampleClass{}...

This is the basis for how the decorators in Angular work. They first of all take a 
configuration value and then receive the class/method/property to apply the decoration 
to. Now that we have a brief understanding of what a decorator actually does, 
we’re going to walk through how Angular creates and uses it’s own decorators.

Lifecycle Hooks:

1. OnChanges: If something is change in your component.
2. OnInit: Everytime that the component is initialitet. The code that is write here, is one time fired
3. DoCheck: Fired by angular if angular things, that a change was performed

Related with contain projection. 
4. AfterContentInit: 
5. AfterContentChecked: 
6. AfterViewInit;
7. AfterViewChecked:

8. OnDestroy: If you remove a component.

Component:
A piece of code that represent something in your screem
Exp: A header, that you will use in every place in your code.
Exp: app.component.ts is a component which is declare in a declaration and bootstrap array in app.module.ts:
@NgModule({ -> class decorator
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { } -> contains all the logic for the component!!!

How to create a component with angular ng ?
1. In the console and in the folder for the application e.g. angularApp
write  
$ng generate component hello
2. Its generate:
a. hello.component.css
b. hello.component.html
c. hello.component.spec.ts
d. hello.component.ts
3. Is generate also an update:
update: app.module.ts -> because module has all component that we use in the application

If I want to use hello component html in app.component...
write in the html form app.commponent <app-hello></app-hello> which 
apply for this block:
templateUrl: './hello.component.html',
styleUrls: ['./hello.component.css'],
after that we should import our hello component in app.component.ts   
import { HelloComponent} from './hello/hello.component';

Interpolation and Expressions:

1. {{ expression }} -> interpolation is use the doble {{}} to realized expressions
2. Not work with bitwiseOR in html. Do it in ts and use a variable. Like in the example!
3. Do not use functions in the html interpolation. Angular will render it 
unnecessary times!!!

One way data binding:

Source (codigo) to target (view) -> []:

Passt data from ts files to html files (interpolation).
a. Write another variable myDisabledValue = false. 
b. constructor() { 
    setInterval(() => {
      this.myVariable = Math.random().toString();
      this.myDisabledValue = Math.random() > 0.5;//if(Math.random() > 0.5) this.myDisabledValue = true;
    }, 500);
  }
c. put the property disable <input type="text" [value]="myVariable" disabled={{myDisabledValue}}>: If
I use this, is allways disable (see DOM)! you work with the configuration of class attibutes
d. <input type="text" [value]="myVariable" [disabled]="myDisabledValue">: If
I use this, is disable with condition you work with values of variables

Resumen:
Para trabajar con configuration de las classes o objetos: attribute="{{valor}}"
Para trabajr con valores en variables: [variable]="valor" 

"Somehting ussefull: 
1. In browser Elements: put mouse over <input type="text"/> (no info about value={{myVariable}})
2. In cosole $0.value -> "Pablo""

Target (view) -> Source (codigo) -> ()